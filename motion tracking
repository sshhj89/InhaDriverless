
//motionTracking.cpp

//Written by  Kyle Hounslow, January 2014

//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software")
//, to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
//and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
//IN THE SOFTWARE.

#include <opencv\cv.h>
#include <opencv\highgui.h>

using namespace std;
using namespace cv;

//our sensitivity value to be used in the threshold() function
const static int SENSITIVITY_VALUE = 20;
//size of blur used to smooth the image to remove possible noise and
//increase the size of the object we are trying to track. (Much like dilate and erode)
const static int BLUR_SIZE = 10;
//we'll have just one object to search for
//and keep track of its position.
int theObject[6] = {0,0};
//bounding rectangle of the object, we will use the center of this as its position.
Rect objectBoundingRectangle1 = Rect(0,0,0,0); // 배열 처리
Rect objectBoundingRectangle2 = Rect(0,0,0,0); // 배열 처리
/*Rect objectBoundingRectangle3 = Rect(0,0,0,0); // 배열 처리
/*Rect objectBoundingRectangle4 = Rect(0,0,0,0); // 배열 처리
Rect objectBoundingRectangle5 = Rect(0,0,0,0); // 배열 처리
Rect objectBoundingRectangle6 = Rect(0,0,0,0); // 배열 처리
Rect objectBoundingRectangle7 = Rect(0,0,0,0); // 배열 처리
Rect objectBoundingRectangle8 = Rect(0,0,0,0); // 배열 처리
Rect objectBoundingRectangle9 = Rect(0,0,0,0); // 배열 처리
Rect objectBoundingRectangle10 = Rect(0,0,0,0); // 배열 처리
*/
//int to string helper function
string intToString(int number){

	//this function has a number input and string output
	std::stringstream ss;
	ss << number;
	return ss.str();
}

void searchForMovement(Mat thresholdImage, Mat &cameraFeed){
	//notice how we use the '&' operator for the cameraFeed. This is because we wish
	//to take the values passed into the function and manipulate them, rather than just working with a copy.
	//eg. we draw to the cameraFeed in this function which is then displayed in the main() function.
	bool objectDetected=false;
	Mat temp;
	thresholdImage.copyTo(temp);
	//these two vectors needed for output of findContours
	vector< vector<Point> > contours;
	vector<Vec4i> hierarchy;
	//find contours of filtered image using openCV findContours function
	//findContours(temp,contours,hierarchy,CV_RETR_CCOMP,CV_CHAIN_APPROX_SIMPLE );// retrieves all contours
	findContours(temp,contours,hierarchy,CV_RETR_EXTERNAL,CV_CHAIN_APPROX_SIMPLE );// retrieves external contours

	//if contours vector is not empty, we have found some objects
	if(contours.size()>0)objectDetected=true;
	else objectDetected = false;

	if(objectDetected){
		//the largest contour is found at the end of the contours vector
		//we will simply assume that the biggest contour is the object we are looking for.
		vector<vector<Point> > largestContourVec;
		//for(int i=0; i< contours.size(); i++)
			largestContourVec.push_back(contours.at(contours.size()-1));
			largestContourVec.push_back(contours.at(contours.size()-2));
			/*largestContourVec.push_back(contours.at(contours.size()-3));
			/*largestContourVec.push_back(contours.at(contours.size()-4));
			largestContourVec.push_back(contours.at(contours.size()-5));
			largestContourVec.push_back(contours.at(contours.size()-6));
			largestContourVec.push_back(contours.at(contours.size()-7));
			largestContourVec.push_back(contours.at(contours.size()-8));
			largestContourVec.push_back(contours.at(contours.size()-9));
			largestContourVec.push_back(contours.at(contours.size()-10));*/
		//make a bounding rectangle around the largest contour then find its centroid
		//this will be the object's final estimated position.
		
		/* for 구현 */
		objectBoundingRectangle1 = boundingRect(largestContourVec.at(0));
		int xpos1 = objectBoundingRectangle1.x+objectBoundingRectangle1.width/2;
		int ypos1 = objectBoundingRectangle1.y+objectBoundingRectangle1.height/2;

		objectBoundingRectangle2 = boundingRect(largestContourVec.at(1));
		int xpos2 = objectBoundingRectangle2.x+objectBoundingRectangle2.width/2;
		int ypos2 = objectBoundingRectangle2.y+objectBoundingRectangle2.height/2;

		/*objectBoundingRectangle3 = boundingRect(largestContourVec.at(2));
		int xpos3 = objectBoundingRectangle3.x+objectBoundingRectangle3.width/2;
		int ypos3 = objectBoundingRectangle3.y+objectBoundingRectangle3.height/2;

		/*objectBoundingRectangle4 = boundingRect(largestContourVec.at(3));
		int xpos4 = objectBoundingRectangle4.x+objectBoundingRectangle4.width/2;
		int ypos4 = objectBoundingRectangle4.y+objectBoundingRectangle4.height/2;

		objectBoundingRectangle5 = boundingRect(largestContourVec.at(4));
		int xpos5 = objectBoundingRectangle5.x+objectBoundingRectangle5.width/2;
		int ypos5 = objectBoundingRectangle5.y+objectBoundingRectangle5.height/2;

		objectBoundingRectangle6 = boundingRect(largestContourVec.at(5));
		int xpos6 = objectBoundingRectangle6.x+objectBoundingRectangle6.width/2;
		int ypos6 = objectBoundingRectangle6.y+objectBoundingRectangle6.height/2;

		objectBoundingRectangle7 = boundingRect(largestContourVec.at(6));
		int xpos7 = objectBoundingRectangle7.x+objectBoundingRectangle7.width/2;
		int ypos7 = objectBoundingRectangle7.y+objectBoundingRectangle7.height/2;

		objectBoundingRectangle8 = boundingRect(largestContourVec.at(7));
		int xpos8 = objectBoundingRectangle8.x+objectBoundingRectangle8.width/2;
		int ypos8 = objectBoundingRectangle8.y+objectBoundingRectangle8.height/2;

		objectBoundingRectangle9 = boundingRect(largestContourVec.at(8));
		int xpos9 = objectBoundingRectangle9.x+objectBoundingRectangle9.width/2;
		int ypos9 = objectBoundingRectangle9.y+objectBoundingRectangle9.height/2;

		objectBoundingRectangle10 = boundingRect(largestContourVec.at(9));
		int xpos10 = objectBoundingRectangle10.x+objectBoundingRectangle10.width/2;
		int ypos10 = objectBoundingRectangle10.y+objectBoundingRectangle10.height/2;*/

		//update the objects positions by changing the 'theObject' array values
		theObject[0] = xpos1 , theObject[1] = ypos1;
		theObject[2] = xpos2 , theObject[3] = ypos2;
		/*theObject[4] = xpos3 , theObject[5] = ypos3;
		/*theObject[6] = xpos4 , theObject[7] = ypos4;
		theObject[8] = xpos5 , theObject[9] = ypos5;
		theObject[10] = xpos6 , theObject[11] = ypos6;
		theObject[12] = xpos7 , theObject[13] = ypos7;
		theObject[14] = xpos8 , theObject[15] = ypos8;
		theObject[16] = xpos9 , theObject[17] = ypos9;
		theObject[18] = xpos10 , theObject[19] = ypos10;*/
	}

	//make some temp x and y variables so we dont have to type out so much
	int x1 = theObject[0];
	int y1 = theObject[1];
	int x2 = theObject[2];
	int y2 = theObject[3];
	/*int x3 = theObject[4];
	int y3 = theObject[5];
	/*int x4 = theObject[6];
	int y4 = theObject[7];
	int x5 = theObject[8];
	int y5 = theObject[9];
	int x6 = theObject[10];
	int y6 = theObject[11];
	int x7 = theObject[12];
	int y7 = theObject[13];
	int x8 = theObject[14];
	int y8 = theObject[15];
	int x9 = theObject[16];
	int y9 = theObject[17];
	int x10 = theObject[18];
	int y10 = theObject[19];*/

	//draw some crosshairs on the object
	circle(cameraFeed,Point(x1,y1),20,Scalar(0,255,0),2);
	line(cameraFeed,Point(x1,y1),Point(x1,y1-25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x1,y1),Point(x1,y1+25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x1,y1),Point(x1-25,y1),Scalar(0,255,0),2);
	line(cameraFeed,Point(x1,y1),Point(x1+25,y1),Scalar(0,255,0),2);
	
	putText(cameraFeed,"(" + intToString(x1-384)+","+intToString(576-y1)+")",Point(x1,y1),1,1,Scalar(255,0,0),2);
	

	//draw some crosshairs on the object
	circle(cameraFeed,Point(x2,y2),20,Scalar(0,255,0),2);
	line(cameraFeed,Point(x2,y2),Point(x2,y2-25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x2,y2),Point(x2,y2+25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x2,y2),Point(x2-25,y2),Scalar(0,255,0),2);
	line(cameraFeed,Point(x2,y2),Point(x2+25,y2),Scalar(0,255,0),2);
	
	putText(cameraFeed,"(" + intToString(x2-384)+","+intToString(576-y2)+")",Point(x2,y2),1,1,Scalar(255,0,0),2);
	

	//draw some crosshairs on the object
	/*circle(cameraFeed,Point(x3,y3),20,Scalar(0,255,0),2);
	line(cameraFeed,Point(x3,y3),Point(x3,y3-25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x3,y3),Point(x3,y3+25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x3,y3),Point(x3-25,y3),Scalar(0,255,0),2);
	line(cameraFeed,Point(x3,y3),Point(x3+25,y3),Scalar(0,255,0),2);
	
	putText(cameraFeed,"(" + intToString(x3-384)+","+intToString(576-y3)+")",Point(x3,y3),1,1,Scalar(255,0,0),2);

	//draw some crosshairs on the object
	/*circle(cameraFeed,Point(x4,y4),20,Scalar(0,255,0),2);
	line(cameraFeed,Point(x4,y4),Point(x4,y4-25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x4,y4),Point(x4,y4+25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x4,y4),Point(x4-25,y4),Scalar(0,255,0),2);
	line(cameraFeed,Point(x4,y4),Point(x4+25,y4),Scalar(0,255,0),2);
	
	putText(cameraFeed,"(" + intToString(x4-384)+","+intToString(576-y4)+")",Point(x4,y4),1,1,Scalar(255,0,0),2);

	//draw some crosshairs on the object
	circle(cameraFeed,Point(x5,y5),20,Scalar(0,255,0),2);
	line(cameraFeed,Point(x5,y5),Point(x5,y5-25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x5,y5),Point(x5,y5+25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x5,y5),Point(x5-25,y5),Scalar(0,255,0),2);
	line(cameraFeed,Point(x5,y5),Point(x5+25,y5),Scalar(0,255,0),2);
	
	putText(cameraFeed,"(" + intToString(x5-384)+","+intToString(576-y5)+")",Point(x5,y5),1,1,Scalar(255,0,0),2);

	//draw some crosshairs on the object
	circle(cameraFeed,Point(x6,y6),20,Scalar(0,255,0),2);
	line(cameraFeed,Point(x6,y6),Point(x6,y6-25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x6,y6),Point(x6,y6+25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x6,y6),Point(x6-25,y6),Scalar(0,255,0),2);
	line(cameraFeed,Point(x6,y6),Point(x6+25,y6),Scalar(0,255,0),2);
	
	putText(cameraFeed,"(" + intToString(x6-384)+","+intToString(576-y6)+")",Point(x6,y6),1,1,Scalar(255,0,0),2);

	//draw some crosshairs on the object
	circle(cameraFeed,Point(x7,y7),20,Scalar(0,255,0),2);
	line(cameraFeed,Point(x7,y7),Point(x7,y7-25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x7,y7),Point(x7,y7+25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x7,y7),Point(x7-25,y7),Scalar(0,255,0),2);
	line(cameraFeed,Point(x7,y7),Point(x7+25,y7),Scalar(0,255,0),2);
	
	putText(cameraFeed,"(" + intToString(x7-384)+","+intToString(576-y7)+")",Point(x7,y7),1,1,Scalar(255,0,0),2);

	//draw some crosshairs on the object
	circle(cameraFeed,Point(x8,y8),20,Scalar(0,255,0),2);
	line(cameraFeed,Point(x8,y8),Point(x8,y8-25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x8,y8),Point(x8,y8+25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x8,y8),Point(x8-25,y8),Scalar(0,255,0),2);
	line(cameraFeed,Point(x8,y8),Point(x8+25,y8),Scalar(0,255,0),2);
	
	putText(cameraFeed,"(" + intToString(x8-384)+","+intToString(576-y8)+")",Point(x8,y8),1,1,Scalar(255,0,0),2);

	//draw some crosshairs on the object
	circle(cameraFeed,Point(x9,y9),20,Scalar(0,255,0),2);
	line(cameraFeed,Point(x9,y9),Point(x9,y9-25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x9,y9),Point(x9,y9+25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x9,y9),Point(x9-25,y9),Scalar(0,255,0),2);
	line(cameraFeed,Point(x9,y9),Point(x9+25,y9),Scalar(0,255,0),2);
	
	putText(cameraFeed,"(" + intToString(x9-384)+","+intToString(576-y9)+")",Point(x9,y9),1,1,Scalar(255,0,0),2);

	//draw some crosshairs on the object
	circle(cameraFeed,Point(x10,y10),20,Scalar(0,255,0),2);
	line(cameraFeed,Point(x10,y10),Point(x10,y10-25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x10,y10),Point(x10,y10+25),Scalar(0,255,0),2);
	line(cameraFeed,Point(x10,y10),Point(x10-25,y10),Scalar(0,255,0),2);
	line(cameraFeed,Point(x10,y10),Point(x10+25,y10),Scalar(0,255,0),2);
	
	putText(cameraFeed,"(" + intToString(x10-384)+","+intToString(576-y10)+")",Point(x10,y10),1,1,Scalar(255,0,0),2);

	*/
}
int main(){

	//some boolean variables for added functionality
	bool objectDetected = false;
	//these two can be toggled by pressing 'd' or 't'
	bool debugMode = false;
	bool trackingEnabled = false;
	//pause and resume code
	bool pause = false;
	//set up the matrices that we will need
	//the two frames we will be comparing
	Mat frame1,frame2;
	//their grayscale images (needed for absdiff() function)
	Mat grayImage1,grayImage2;
	//resulting difference image
	Mat differenceImage;
	//thresholded difference image (for use in findContours() function)
	Mat thresholdImage;
	//video capture object.
	VideoCapture capture;

	while(1){

		//we can loop the video by re-opening the capture every time the video reaches its last frame

	
			capture.open("C:\\Users\\경철\\Desktop\\pedestrian.avi");
		
		if(!capture.isOpened()){
			cout<<"ERROR ACQUIRING VIDEO FEED\n";
			getchar();
			return -1;
		}



		//check if the video has reach its last frame.
		//we add '-1' because we are reading two frames from the video at a time.
		//if this is not included, we get a memory error!
		while(capture.get(CV_CAP_PROP_POS_FRAMES)<capture.get(CV_CAP_PROP_FRAME_COUNT)-1){

			//read first frame
			capture.read(frame1);
			//convert frame1 to gray scale for frame differencing
			cv::cvtColor(frame1, grayImage1, COLOR_BGR2GRAY);
			//copy second frame
			capture.read(frame2);
			//convert frame2 to gray scale for frame differencing
			cv::cvtColor(frame2, grayImage2, COLOR_BGR2GRAY);
			//perform frame differencing with the sequential images. This will output an "intensity image"
			//do not confuse this with a threshold image, we will need to perform thresholding afterwards.
			cv::absdiff(grayImage1,grayImage2,differenceImage);
			//threshold intensity image at a given sensitivity value
			cv::threshold(differenceImage, thresholdImage, SENSITIVITY_VALUE, 255, THRESH_BINARY);
			if(debugMode==true){
				//show the difference image and threshold image
				cv::imshow("Difference Image", differenceImage);
				cv::imshow("Threshhold Image", thresholdImage);
			}else{
				//if not in debug mode, destroy the windows so we don't see them anymore
				cv::destroyWindow("Difference Image");
				cv::destroyWindow("Threshhold Image");
			}
			//use blur() to smooth the image, remove possible noise and
			cv::blur(thresholdImage, thresholdImage , cv::Size(BLUR_SIZE,BLUR_SIZE));
			//increase the size of the object we are trying to track. (Much like dilate and erode)

			//threshold again to obtain binary image from blur output
			cv::threshold(thresholdImage,thresholdImage,SENSITIVITY_VALUE,255,THRESH_BINARY);
			if(debugMode==true){
				//show the threshold image after it's been "blurred"
				imshow("Final Threshold Image",thresholdImage);
			}
			else {
				//if not in debug mode, destroy the windows so we don't see them anymore
				cv::destroyWindow("Final Threshold Image");
			}

			//if tracking enabled, search for contours in our thresholded image
			if(trackingEnabled){

				searchForMovement(thresholdImage, frame1);
			}
			//show our captured frame
			imshow("Frame1",frame1);
			//check to see if a button has been pressed.
			//this 10ms delay is necessary for proper operation of this program
			//if removed, frames will not have enough time to referesh and a blank 
			//image will appear.
			switch(waitKey(10)){

			case 27: //'esc' key has been pressed, exit program.
				return 0;
			case 116: //'t' has been pressed. this will toggle tracking
				trackingEnabled = !trackingEnabled;
				if(trackingEnabled == false) cout<<"Tracking disabled."<<endl;
				else cout<<"Tracking enabled."<<endl;
				break;
			case 100: //'d' has been pressed. this will debug mode
				debugMode = !debugMode;
				if(debugMode == false) cout<<"Debug mode disabled."<<endl;
				else cout<<"Debug mode enabled."<<endl;
				break;
			case 112: //'p' has been  pressed. this will pause/resume the code.
				pause = !pause;
				if(pause == true){ cout<<"Code paused, press 'p' again to resume"<<endl;
				while (pause == true){
					//stay in this loop until 
					switch (waitKey()){
						//a switch statement inside a switch statement? Mind blown.
					case 112: 
						//change pause back to false
						pause = false;
						cout<<"Code resumed."<<endl;
						break;
					}
				}
				}


			}


		}
		//release the capture before re-opening and looping again.
		capture.release();
	}

	return 0;

}
